"""Async orchestration utilities for the Phase 5 audio pipeline."""

from __future__ import annotations

import asyncio
from dataclasses import dataclass, field
from pathlib import Path
from typing import Iterable, List, Optional, Sequence

from pydantic import ValidationError

from app.packages.models_generated import Chapter, QCReport, Segment
from app.packages.tts import batch_synth
from app.packages.mastering import mixer
from app.packages.exporters import audio_exporter, notes_generator


class Phase5OrchestrationError(RuntimeError):
    """Raised when any stage of the Phase 5 pipeline fails."""


@dataclass(slots=True)
class Phase5Artifacts:
    """Container for artifacts generated by the Phase 5 pipeline."""

    stems: List[Path]
    mix_path: Path
    export_dir: Path
    notes_path: Path
    qc_report: Optional[QCReport] = None
    summary: dict[str, float] = field(default_factory=dict)


async def generate_stems(
    script_path: Path,
    stems_dir: Path,
    config_path: Path,
) -> List[Path]:
    """Run the batch synthesizer in a worker thread and return generated stems."""

    try:
        stems = await asyncio.to_thread(
            batch_synth.synthesize_batch,
            str(script_path),
            str(stems_dir),
            str(config_path),
        )
    except Exception as exc:  # pragma: no cover - passthrough safeguard
        raise Phase5OrchestrationError("Failed to synthesize stems") from exc
    return [Path(path).resolve() for path in stems]


async def mix_audio(stems_dir: Path, output_mix: Path) -> Path:
    """Run the mixer module to produce a mastered WAV file."""

    output_mix.parent.mkdir(parents=True, exist_ok=True)
    try:
        await asyncio.to_thread(mixer.mix_stems, str(stems_dir), str(output_mix))
    except Exception as exc:  # pragma: no cover - passthrough safeguard
        raise Phase5OrchestrationError("Failed to mix stems") from exc
    return output_mix.resolve()


async def export_derivatives(mix_path: Path, export_dir: Path) -> Path:
    """Export derivative audio assets (MP3/Opus) from the mastered WAV."""

    try:
        await asyncio.to_thread(
            audio_exporter.export_audio,
            str(mix_path),
            str(export_dir),
        )
    except Exception as exc:  # pragma: no cover - passthrough safeguard
        raise Phase5OrchestrationError("Failed to export audio derivatives") from exc
    return export_dir.resolve()


async def generate_notes(script_path: Path, notes_path: Path) -> Path:
    """Produce show notes markdown based on the assembled script."""

    notes_path.parent.mkdir(parents=True, exist_ok=True)
    try:
        await asyncio.to_thread(
            notes_generator.generate_notes,
            str(script_path),
            str(notes_path),
        )
    except Exception as exc:  # pragma: no cover - passthrough safeguard
        raise Phase5OrchestrationError("Failed to generate notes") from exc
    return notes_path.resolve()


def _coerce_segments(segments: Optional[Sequence[Segment | dict]]) -> List[Segment]:
    if not segments:
        return []
    coerced: List[Segment] = []
    for item in segments:
        if isinstance(item, Segment):
            coerced.append(item)
            continue
        try:
            coerced.append(Segment.model_validate(item))
        except ValidationError as exc:
            raise Phase5OrchestrationError("Segment payload failed validation") from exc
    return coerced


def _coerce_chapters(chapters: Optional[Sequence[Chapter | dict]]) -> List[Chapter]:
    if not chapters:
        return []
    coerced: List[Chapter] = []
    for item in chapters:
        if isinstance(item, Chapter):
            coerced.append(item)
            continue
        try:
            coerced.append(Chapter.model_validate(item))
        except ValidationError as exc:
            raise Phase5OrchestrationError("Chapter payload failed validation") from exc
    return coerced


async def run_full_pipeline(
    script_path: Path,
    stems_dir: Path,
    mix_path: Path,
    export_dir: Path,
    notes_path: Path,
    *,
    config_path: Path = Path("configs/hosts.yaml"),
    segments: Optional[Sequence[Segment | dict]] = None,
    chapters: Optional[Sequence[Chapter | dict]] = None,
    existing_qc_report: Optional[QCReport | dict] = None,
) -> Phase5Artifacts:
    """Execute the Phase 5 pipeline end-to-end and return generated artifacts."""

    script_path = script_path.resolve()
    stems_dir = stems_dir.resolve()
    mix_path = mix_path.resolve()
    export_dir = export_dir.resolve()
    notes_path = notes_path.resolve()
    config_path = config_path.resolve()

    validated_segments = _coerce_segments(segments)
    validated_chapters = _coerce_chapters(chapters)

    qc_report: Optional[QCReport]
    if existing_qc_report is None:
        qc_report = None
    elif isinstance(existing_qc_report, QCReport):
        qc_report = existing_qc_report
    else:
        try:
            qc_report = QCReport.model_validate(existing_qc_report)
        except ValidationError as exc:
            raise Phase5OrchestrationError("QC report payload failed validation") from exc

    stems = await generate_stems(script_path, stems_dir, config_path)
    mix = await mix_audio(stems_dir, mix_path)

    async with asyncio.TaskGroup() as task_group:  # Run exports and notes in parallel.
        export_task = task_group.create_task(export_derivatives(mix, export_dir))
        notes_task = task_group.create_task(generate_notes(script_path, notes_path))

    export_root = export_task.result()
    notes_file = notes_task.result()

    summary: dict[str, float] = {}
    if validated_segments:
        total_duration = sum(segment.duration_seconds() for segment in validated_segments)
        summary["segments_duration_seconds"] = float(total_duration)
        summary["segment_count"] = float(len(validated_segments))
    if validated_chapters:
        chapter_duration = sum(chapter.duration_ms for chapter in validated_chapters) / 1000
        summary["chapters_duration_seconds"] = float(chapter_duration)
        summary["chapter_count"] = float(len(validated_chapters))

    return Phase5Artifacts(
        stems=stems,
        mix_path=mix,
        export_dir=export_root,
        notes_path=notes_file,
        qc_report=qc_report,
        summary=summary,
    )


__all__ = [
    "Phase5Artifacts",
    "Phase5OrchestrationError",
    "generate_stems",
    "mix_audio",
    "export_derivatives",
    "generate_notes",
    "run_full_pipeline",
]